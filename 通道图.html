<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./js/d3.min.js"></script>
</head>
<body>
    <span>
        <input type="text" onblur="setStart(this)" value="30">
        --
        <input type="text" onblur="setEnd(this)" value="30.2">
    </span>
    <button onclick="updateMap()">确定</button>
    <svg id="channels" width="1600" height="800"></svg>
    <script>
        let allData, allChannels;
        const svg = d3.select("#channels");
        const width = +svg.attr('width');
        const height = +svg.attr('height');
        const margin = {top: 60, right: 60, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        let yHeight;
        const g = svg.append("g")
        .attr("id", "mainGroup")
        .attr("transform", `translate(${margin.left}, ${margin.top})`)
        let scaleX, scaleY, scaleV, scaleG, axisBottom, axisLeft, path;
        let timeRange = [30, 30.20]
        let timeFragment;

        function setStart(evt) {
            timeRange[0] = Number(evt.value)
        }

        function setEnd(evt) {
            timeRange[1] = Number(evt.value)
        }

        const line = d3.line()
        .defined(d => !isNaN(d))
        .x((d, i) => scaleX(timeFragment[i]))
        .y((d, i) => scaleV(d))

        function splitAxisY(height, data) {
            const range = height / data.length;
            let curBasic = 0, result = {};
            for (let index = 0; index < data.length; index++) {
                result[data[index].name] = [curBasic, curBasic + range]
                curBasic = curBasic + range
            }
            return result;
        }

        d3.json("http://127.0.0.1:8080/json.json").then(data => {
            allData = data
            const channels = []
            Object.keys(data.subData.channels).forEach(key => {
                channels.push({
                    name: key,
                    value: data.subData.channels[key]
                })  
            });
            allChannels = channels

            let current = data.subData.time.indexOf(timeRange[0]),
            endIndex = data.subData.time.indexOf(timeRange[1]) + 1
            timeFragment = data.subData.time.slice(current, endIndex)

            let curChannel = []
            for (let i = 0; i < channels.length; i++) {
                curChannel.push({
                    name: channels[i].name,
                    value: channels[i].value.slice(current, endIndex)
                })
            }
            
            scaleX = d3.scaleLinear()
            .domain(d3.extent(data.subData.time.slice(current, endIndex)))
            .range([0, innerWidth])
            .nice()
            
            scaleY = d3.scaleBand()
            .domain(curChannel.map(channel => channel.name))
            .range([0, innerHeight].reverse())
            .padding(0.15)

            let range = d3.extent(data.subData.time.slice(current, endIndex))
            axisBottom = d3.axisBottom(scaleX)
            .ticks(20, 200)

            axisLeft = d3.axisLeft(scaleY)

            g.append("g").attr("class", "x_axis")
            .attr("transform", `translate(0, ${innerHeight})`)
            .call(axisBottom)

            g.append("g").attr("class", "y_axis")
            .call(axisLeft)

            xWidth = d3.select(".x_axis .domain").node().getBBox().width
            yHeight = d3.select(".y_axis .domain").node().getBBox().height
            const domains = splitAxisY(yHeight, curChannel)

            scaleV = {}
            curChannel.forEach(channel => {
                scaleV[channel.name] = d3.scaleLinear()
                .domain([d3.min(channel.value), d3.max(channel.value)])
                .range([domains[channel.name][0], domains[channel.name][1]])
            })
            
            scaleG = d3.scaleLinear()
            .domain([0, 13])
            .range([0, innerHeight].reverse())

            drawGrid(xWidth, yHeight)

            path = g.append("g")
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 1.5)
            .attr("stroke-linejoin", "round")
            .attr("stroke-linecap", "round")
            .selectAll("path")
            .data(curChannel)
            .join("path")
            .attr("class", "channel_line")
            .style("mix-blend-mode", "multiply")
            .attr("d", data => {
                let line = d3.line().defined(d => !isNaN(d))
                .x((d, i) => scaleX(timeFragment[i]))
                .y(d => scaleV[data.name](d))
                return line(data.value)
            });
        })

        function drawGrid(xWidth, yHeight) {
            g.selectAll("line.horizontalGrid").data(scaleX.ticks(200))
            .join("line")
            .attr("fill", "none")
            .attr("stroke", "#ccc")
            .attr("stroke-width", "1.2")
            .attr("x1", d => scaleX(d))
            .attr("y1", 0)
            .attr("x2", d => scaleX(d))
            .attr("y2", yHeight)
            console.log(scaleG.ticks(130))
            g.selectAll("line.verticalGrid").data(scaleG.ticks(130))
            .join("line")
            .attr("fill", "none")
            .attr("stroke", "#ccc")
            .attr("stroke-width", "1.2")
            .attr("x1", 0)
            .attr("y1", d => scaleG(d))
            .attr("x2", xWidth)
            .attr("y2", d => scaleG(d))
        }

        function updateMap() {
            let newTime, newChannels = [];
            let current = allData.subData.time.indexOf(timeRange[0]),
            endIndex = allData.subData.time.indexOf(timeRange[1]) + 1;
            // newTime = timeRange.concat(allData.subData.time.slice(current, endIndex))
            console.log(allData.subData.time.slice(current, endIndex))
            scaleX.domain(d3.extent(allData.subData.time.slice(current, endIndex)))
            timeFragment = allData.subData.time.slice(current, endIndex)
            axisBottom.scale().domain(d3.extent(allData.subData.time.slice(current, endIndex))).range([0, innerWidth])
            d3.select(".x_axis").call(axisBottom)
            
            for (let i = 0; i < allChannels.length; i++) {
                newChannels.push({
                    name: allChannels[i].name,
                    value: allChannels[i].value.slice(current, endIndex)
                })
            }

            const domains = splitAxisY(yHeight, newChannels)
            scaleV = {}
            newChannels.forEach(channel => {
                scaleV[channel.name] = d3.scaleLinear()
                .domain([d3.min(channel.value), d3.max(channel.value)])
                .range([domains[channel.name][0], domains[channel.name][1]])
            })
            
            g.selectAll(".channel_line")
            .data(newChannels)
            .transition()
            .duration(1000)
            .attr("d", data => {
                let line = d3.line().defined(d => !isNaN(d))
                .x((d, i) => scaleX(timeFragment[i]))
                .y(d => scaleV[data.name](d))
                return line(data.value)
            })
        }
    </script>
</body>
</html>